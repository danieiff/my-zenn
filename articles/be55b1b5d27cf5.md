---
title: "業務Webアプリ向けBaaS vte.cx (by Virtual Technology㈱)に入門"
emoji: "️🖥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vtecx", "react", "typescript", "materialui"]
published: false
---

vte.cx(ヴィーテックス) [歩き方](https://qiita.com/stakezaki/items/e526ca061d8f004db7f5) と 当時の雰囲気↓
https://www.youtube.com/watch?v=d8LCtgKqKoc
API設計に普遍的、直感的な規約が整備されていて、フロントエンドエンジニアはBFFの領域で安全にサーバーリソースを扱えます。
APIサーバーの構築と、保守、拡張、運用に全く手がかかりません。
バックエンドについて最低限の知識で、多様なビジネスロジックに対応したアプリケーションを構築してリリースすることができます｡

以下､ vte.cx, React, TypeScript, Material UI による
Create, Read(+ページネーション, データベース検索), Update, Deleteアプリの実装記録です｡
## 構成
```
─ src/components/
  ├─ index.tsx 3つのページをルーティング            ・・・(3)
  ├─ Register.tsx 新規登録ページ '/register'      ・・・(1)
  ├─ dataTableComponents/
  │    ├─ Table.tsx データ一覧表示ページ '/'   ・・・(2)
  │    │   表示データGET通信(ページネーション・・・(5)､データベース検索・・・(6))
  │    ├─ Edit.tsx 既存データ編集ページ '/edit'    ・・・(4)
  │    └─ Delete.tsx 既存データ削除
  ├─ Pagination.tsx                             ・・・(5)
  ├─ SearchField.tsx
  │   ユーザーの入力から､表示データGET通信にのせる検索用パラメータを生成します｡
  │                                             ・・・(6)
  └ formComponents/{~Input}.tsx
     フォーム項目ごとに雛形コンポーネント､ファイルを作成
```
## (1)~(6)をさらっていきます
### (1) 新規登録フォーム Register.tsx
>vte.cx, Controlled Form, Yup, Axios

APIサーバーを立てて認証を済ませ、**エンドポイント**と**スキーマ**を設定してから次に進みます。
```ts
axios.post('/d/{エンドポイント}', {/* スキーマ定義通りの内容のオブジェクト */})
```
:::details フォームコンポーネントの説明
```ts:Register.tsx
import { useState } from 'react'
const Register = () => {
  const [state,setState] = useState('')
  const handleSubmit = () => //
  return (
    <form></form>
  )
}
```
Controlled Form, Uncontrolled Formがありますが、
:::
(1)の反省
---
参考記事を一通り理解する→ドキュメントを一通り理解するというやり方をしているが､参考記事でお腹いっぱいになり､(4)の時点で初めてドキュメントにスキーマ定義の記述を発見した｡
オフィスで､記事より長いドキュメントにへばりついて､傍から見るとタイピングせずにずっとモニターを見てるだけの人と思われると思ったので､相当後回しにした｡
10項目すべて登録不必要にし､スキーマから出力した型とは別に型定義した｡ 10項目もあると型定義も大変だった｡チェックボックス項目では､この項目を登録しないという選択肢をつくって､一覧表示するときに値があるかチェックするという実装をせめて選ぶべきだった｡ (詳しく書く)
スキーマ定義
フォームコンポーネント系の設計､共通化で詰まった｡
10項目**フォーム入力要素のtypeごと** or **フォーム入力項目ごと** に雛形コンポーネントを作成するかつまった｡入力項目ごとにPropsや挙動を変えるかもしれないので､前者ではなく後者を選択した｡
雛形を使うRegister...10項目入力, Edit...10項目入力\*選択したエントリの数, SearchField...横に長く並べる､､､というふうにそれぞれでGridレイアウトが違うので､レイアウトを共通化できなかったが､共通化しようと悩んだ｡
一つの入力項目コンポーネントにPropsでモードの文字列を渡して､このコンポーネントが使われる場所ごとに特定の文字列を'モード'としてわたして他のPropsやロジックを条件分岐ごとに書き分けられることを学んだ｡
Material UIのテーマをカスタマイズ､CSSを手作りすることを避けた｡

### (2) データ一覧表示 DataTable.tsx
>Data Grid コンポーネント(Material UI)

```ts:DataTable.tsx
useEffect(()=>{/* まずaxios.getし､レスポンスをstateに持たせる｡ */},[])
```
**失敗時**
```ts:DataTable.tsx
import { GridOverlay } from '@mui/x-data-grid'
<DataGrid
  // ...
  components={{
    NoRowsOverlay: ()=>
      <GridOverlay>{state.errorMsg||'データ0件'}</GridOverlay>}
  }}
/>
```
**成功時**
```ts
// ↓のレスポンスを整形してstateに持たせた
{
  data: [
    {
      user,
      id,
      link: [/* hrefとrelationプロパティの組をもつオブジェクト(1つ以上) */],
      ...
    },
    ...
  ],
 /* ... 残りは不要 */
}
// ↓ 整形
[ {...user, id, link }, ... ]
```
```ts:DataTable.tsx
import { DataGrid } from '@mui/x-data-grid'
//DataTableコンポーネントの外
// 一覧表示される項目(=列column)ごとの設定
const columns = [
  // 一覧表示されるstate.feed配列の中のオブジェクト(=行row)のageプロパティについての設定
  {
    field: 'age',
    headerName: '年齢',
    width: '100px',
    renderCell: catchUnregistered(
      (params: GridValueFormatterParams & { value: string }) => value + '歳'
    ) // renderCellプロパティの説明は後述
  },
  ...
]
// DataTableコンポーネント内
<DataGrid
  columns={columns}
  rows={state.feed} // 整形済み[ {...user, id, link }, ... ]
/>
```
:::details `DataGrid`のProps `columns`の`renderCell`プロパティの説明
DataGrid APIでは､ある行rowのオブジェクトの中に列columnに含まれるフィールド名のプロパティがないと空欄になる｡
代わりに未登録を明示するために高階関数を使い､コードを読みやすくしました｡
一覧表UIのライブラリを比較検討するか､自作するにしろ､最初に仕様を吟味するべきでした｡
DataGridのProps `columns`の`renderCell`プロパティの中身は､`GridValueFormatterParams`型のparamsが引数で､プリミティブ型やJSX.Element型が返り値の関数になります｡ この返り値が一覧表に表示されます｡

```ts:dataTable.tsx
import { GridCellValue, GridValueFormatterParams } from '@mui/x-data-grid'
// コンポーネントの外側
const catchUnregistered =
  (formatterFunc?: (params: GridValueFormatterParams) => GridCellValue) =>
  // このcatchUnregisteredは以下を返す｡
  (params: GridValueFormatterParams) =>
    params.value && params.value !== '' ? ( // 未登録か?
      formatterFunc ? ( // 関数が渡されたか?
        formatterFunc(params) // 渡された関数でフォーマットされた登録値を返す関数
      ) : (
        params.value // 登録値をそのまま返す関数
      )
    ) : (
      <p style={{ color: 'silver' }}>Not Registered</p>
      // 未登録を明示するhtml要素を返す関数
    )
```
:::
### (3) (1)と(2)をルーティング index.tsx
>React Router
```ts:index.tsx
import {HashRouter, Switch, Route} from 'react-router-dom'
// ...
 <HashRouter hashType="noslash">
   <Menu /> // メニューコンポーネント
   <Switch>
  // <indicatorContext.Provider
    // value={{ indicatorState, indicatorDispatch }}
  // >
       <Route path="/register">
         <Register /> // 登録コンポーネント
        </Route>
        <Route path="/edit">
          <Edit /> // 編集コンポーネント
        </Route>
        <Route exact path="/">
          <DataTable /> // 一覧コンポーネント
        </Route>
   // </indicatorContext.Provider>
    </Switch>
 // Reactのコンテキストを使って､CRUDアクションごとに通知を表示します｡
 // {indicatorState.isShow &&
   // <Indicator
     // message={indicatorState.msg}
     // onClick={indicatorDispatch({type:'hide'})}
   // />
 // }
// ...
```
`<Switch></Switch>`の外側の`<Menu />`はパスに関係なく表示されます｡
今後､`Switch`の入れ子パターンや､他のAPIも使うことになるでしょう｡
### (4) データ編集 Edit.tsx
>onSelectionModelChange (Data Grid API), Promise.all

データ削除
### (5) ページネーション
>vte.cx クエリパラメータ

**一覧表示ページを切り替えるごとに､表示するエントリを逐一サーバーからGETしています｡**
### (6) 検索
>正規表現､ vte.cx クエリパラメータ

フォームtext type入力項目 完全一致､どれか含む､ 含まないという条件
データベースの'名前'項目に対して､下の名前､上の名前別々で検索できるように正規表現を工夫 ('名','姓'をスキーマ定義してデータベースの項目を分けるべきだった｡)

→
## 総括
一番目に思い返すことは､CSSを書かず､Material UIのコンポーネントをそのまま使いまくったことです｡
vte.cx, React, TypeScript, Material UI,その他の知識を埋めながら開発していて､行き当たりばったりで書いていくので必ずどこかが壊れていたり､エラーが出るたびにフレームワーク名+警告文で一つずつGoogle検索していくことも少なくありませんでした｡
APIの実装例を調べて､コードを書いて､画面の表示確認して､コードを修正するという試行錯誤を繰り返すというフロントエンド開発な地道な面を体感しました｡
vte.cxは簡単に慣れて､扱いやすかったです｡学ぶべき強力な機能もたくさんあります｡
以上で学んだ経験と知識を業務に活かすとともに､CSSを仲間にすること､Material UIのカスタマイズ､テストの見識を深めることを個人的な課題として取り組んでまいります｡