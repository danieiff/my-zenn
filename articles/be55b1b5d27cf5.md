---
title: "業務Webアプリ向けBaaS vte.cx (by Virtual Technology㈱)に入門"
emoji: "️🖥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vtecx", "react", "typescript", "materialui"]
published: false
---

vte.cx(ヴィーテックス) [歩き方](https://qiita.com/stakezaki/items/e526ca061d8f004db7f5) と 当時の雰囲気↓
https://www.youtube.com/watch?v=d8LCtgKqKoc
API設計は普遍的、直感的な規約に守られていて、フロントエンドエンジニアはBFFの領域で安全にサーバーリソースを扱えます。
APIサーバーの構築と、保守、拡張、運用に全く手がかかりません。
バックエンドについて最低限の知識で、多様なビジネスロジックに対応したアプリケーションを構築してリリースすることができます｡

以下､ vte.cx, React, TypeScript, Material UI による
Create, Read(+ページネーション, データベース検索), Update, Deleteアプリの実装記録です｡
## 構成
```
─ src/components/
  ├─ index.tsx 3つのページをルーティング            ・・・(3)
  ├─ Register.tsx 新規登録ページ '/register'       ・・・(1)
  ├─ dataTableComponents/
  │    ├─ Table.tsx データ一覧表示ページ '/'        ・・・(2)
  │    │   表示データGET通信(ページネーション・・・(5)､データベース検索・・・(6))
  │    ├─ Edit.tsx 既存データ編集ページ '/edit'     ・・・(4)
  │    └─ Delete.tsx 既存データ削除
  ├─ Pagination.tsx                               ・・・(5)
  ├─ SearchField.tsx
  │   ユーザーの入力から､表示データGET通信にのせる検索用パラメータを生成します｡
  │                                               ・・・(6)
  └ formComponents/{~Input}.tsx
     フォーム項目ごとに雛形コンポーネント､ファイルを作成
```
## (1)~(6)をさらっていきます
### (1) 新規登録フォーム Register.tsx
>vte.cx, Axios, Controlled Form, Yup
#### APIを用意~利用する
vte.cxを使ってAPIサーバーを用意し、**エンドポイント**と**スキーマ**を設定します｡
```ts
axios.post('/d/{エンドポイント}', [ {/* スキーマ定義通りの内容のオブジェクト */} ])
```
vte.cxではリクエストのヘッダ設定が必要です｡
```ts
axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'
```
#### 最後(6)まで(とりあえずフォームまで)コーディング
Controlled Form
親のRegisterコンポーネントが**state**と**onChange**でフォーム入力(→状態State)を管理(→100歩譲って"*上書き*")すること｡
ユーザーの入力に伴って再描画のたびにUIを変えるパターン｡
```ts:Register.tsx
import { useState } from 'react'
const Register = () => {
  const [firstname, setFirstname] = useState(undefined)
  // vte.cxスキーマ定義からファイル生成される型を使うこと｡
  // ...他項目
  const handleSubmit = ( event: React.FormEvent<HTMLFormElement> ) => {
    event.preventDefault()
    const user = { firstname /*,...*/ }
    // 前述の2行のaxiosのコード + 例外処理
  }
  return (
    <form onSubmit={handleSubmit} >
      <input value={firstname} onChange={setFirstname} />
      <input type="submit" />
    </form>
  )
}
```
Uncontrolled Form
各入力コンポーネントが入力を管理すること｡ UIを変えないので**useRef**を使って再描画させないパターン｡
```ts
const Uncontrolled_Form = () => {
  const firstnameRef = useRef( {} as HTMLInputElement )
  // ...他項目
  const handleSubmit = (event/*:型*/) => {
    const user = { firstname: inputRef.current.value /*,...*/ }
    // ...
  }
  // ...
  <input ref={firstnameRef} />
}
```
[Controlled and uncontrolled form](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/#conclusion)
↓と ライブラリReact Final Formを組み合わせて実装しましょう｡
:::details バリデーションライブラリYup
```ts: Register.tsx
import * as yup from 'yup'
// コンポーネントの外側
const schema = yup.object().shape({
  firstname: yup.string().required('必須')
  middlename: yup.string(),
  lastname: yup.string().required('必須'),
  email: yup.string().email('無効なメールアドレス')
})
// 内側
const [firstname, setFirstname] = useState(undefined)
const [error, setError] = useState({ firstname: '' /*,...*/ })
const handleSubmit = async (event) => {
  try {
    const result = await schema.validate({ firstname /*,...*/ })
    // 送信
  } catch (error) {
    setError({ [error.path]: error.message }) //
  }
}
return (
  <form onSubmit={handleSubmit} >
    <label>名</label>
    <input onChange={setFirstname} />
    {error.firstname || <></>}
    // ...
  </form>
)
```
validation関数でthrowされるerrorオブジェクト
```ts
{
  name: 'ValidationError',
  value: {/* バリデーションされたオブジェクトのコピー*/},
  path: '最初にひっかかった項目の名前',
  type: 'yupライブラリ内部バリデーション処理で最初にひっかかったエラーの名前',
  errors: ['上のエラーの警告文'],
  inner: [] // validate(,第2引数{ abortEarly: false })と指定したとき
  // [ひっかかったすべての項目ごとに{第一階層の形式},{〃}, ...}
  message: '上コードのschemaに文errorsプロパティの文',
}
```
[Yup](https://github.com/jquense/yup)はスキーマをもとにパース､バリデーションするためのライブラリです｡
:::
出だしの反省
---
ピックアップした参考記事を一通り理解する→ドキュメントを一通り理解するというやり方をしているが､参考記事でお腹いっぱいになり､(4)の時点で初めてドキュメントにスキーマ定義の記述を発見した｡
オフィスで､長いドキュメントにへばりついて､傍から見るとタイピングせずにずっとモニターを見てるだけの人と思われると思ったので､相当後回しにした｡
記事の情報だけでやったスキーマ定義からフォームコンポーネント系の設計､共通化で詰まった｡
- 10項目**フォーム入力要素のtypeごと** or **フォーム入力項目ごと** に雛形コンポーネントを作成するかつまった｡入力項目ごとにPropsや挙動を変えるので後者を選択した｡
- 10項目フォーム周りの型の扱いに苦戦した｡スキーマ定義から出力された型ファイルを有効に利用できなかった｡
- stateの形とかいろいろなところで試行錯誤して､コーディングスタイルの問題に取り組んだ｡
### (2) データ一覧表示 DataTable.tsx
>Data Grid コンポーネント(Material UI)

```ts:DataTable.tsx
useEffect(()=>{/* まずaxios.getし､レスポンスをstateに持たせる｡ */},[])
```
**失敗時**
```ts:DataTable.tsx
import { GridOverlay } from '@mui/x-data-grid'
<DataGrid
  // ...
  components={{
    NoRowsOverlay: ()=>
      <GridOverlay>{state.errorMsg||'データ0件'}</GridOverlay>}
  }}
/>
```
**成功時**
```ts
// ↓のレスポンスを整形してstateに持たせた
{
  data: [
    {
      user,
      id,
      link: [/* hrefとrelationプロパティの組をもつオブジェクト(1つ以上) */],
      ...
    },
    ...
  ],
 /* ... 残りは不要 */
}
// ↓ 整形
[ {...user, id, link }, ... ]
```
```ts:DataTable.tsx
import { DataGrid } from '@mui/x-data-grid'
//DataTableコンポーネントの外
// 一覧表示される項目(=列column)ごとの設定
const columns = [
  // 一覧表示されるstate.feed配列の中のオブジェクト(=行row)のageプロパティについての設定
  {
    field: 'age',
    headerName: '年齢',
    width: '100px',
    renderCell: catchUnregistered(
      (params: GridValueFormatterParams & { value: string }) => value + '歳'
    ) // renderCellプロパティの説明は後述
  },
  ...
]
// DataTableコンポーネント内
<DataGrid
  columns={columns}
  rows={state.feed} // 整形済み[ {...user, id, link }, ... ]
/>
```
:::details `DataGrid`のProps `columns`の`renderCell`プロパティの説明
DataGrid APIでは､ある行rowのオブジェクトの中に列columnに含まれるフィールド名のプロパティがないと空欄になる｡
代わりに未登録を明示するために高階関数を使い､コードを読みやすくしました｡
一覧表UIのライブラリを比較検討するか､自作するにしろ､最初に仕様を吟味するべきでした｡
DataGridのProps `columns`の`renderCell`プロパティの中身は､`GridValueFormatterParams`型のparamsが引数で､プリミティブ型やJSX.Element型が返り値の関数になります｡ この返り値が一覧表に表示されます｡

```ts:dataTable.tsx
import { GridCellValue, GridValueFormatterParams } from '@mui/x-data-grid'
// コンポーネントの外側
const catchUnregistered =
  (formatterFunc?: (params: GridValueFormatterParams) => GridCellValue) =>
  // このcatchUnregisteredは以下を返す｡
  (params: GridValueFormatterParams) =>
    params.value && params.value !== '' ? ( // 未登録か?
      formatterFunc ? ( // 関数が渡されたか?
        formatterFunc(params) // 渡された関数でフォーマットされた登録値を返す関数
      ) : (
        params.value // 登録値をそのまま返す関数
      )
    ) : (
      <p style={{ color: 'silver' }}>Not Registered</p>
      // 未登録を明示するhtml要素を返す関数
    )
```
:::
### (3) (1)と(2)をルーティング index.tsx
>React Router
```ts:index.tsx
import {HashRouter, Switch, Route} from 'react-router-dom'
// ...
 <HashRouter hashType="noslash">
   <Menu /> // メニューコンポーネント
   <Switch>
  // <indicatorContext.Provider
    // value={{ indicatorState, indicatorDispatch }}
  // >
       <Route path="/register">
         <Register /> // 登録コンポーネント
        </Route>
        <Route path="/edit">
          <Edit /> // 編集コンポーネント
        </Route>
        <Route exact path="/">
          <DataTable /> // 一覧コンポーネント
        </Route>
   // </indicatorContext.Provider>
    </Switch>
 // Reactのコンテキストを使って､CRUDアクションごとに通知を表示します｡
 // {indicatorState.isShow &&
   // <Indicator
     // message={indicatorState.msg}
     // onClick={indicatorDispatch({type:'hide'})}
   // />
 // }
// ...
```
`<Switch></Switch>`の外側の`<Menu />`はパスに関係なく表示されます｡
今後､`Switch`の入れ子パターンや､他のAPIも使うことになるでしょう｡
### (4) データ編集 Edit.tsx
>onSelectionModelChange (Data Grid API), Promise.all

データ削除
### (5) ページネーション
>vte.cx クエリパラメータ

**一覧表示ページを切り替えるごとに､表示するエントリを逐一サーバーからGETしています｡**
### (6) 検索
>正規表現､ vte.cx クエリパラメータ

フォームtext type入力項目 完全一致､どれか含む､ 含まないという条件
データベースの'名前'項目に対して､下の名前､上の名前別々で検索できるように正規表現を工夫 ('名','姓'をスキーマ定義してデータベースの項目を分けるべきだった｡)

→
## 総括
一番目に思い返すことは､CSSを書かず､Material UIのコンポーネントをそのまま使いまくったことです｡
vte.cx, React, TypeScript, Material UI,その他の知識を埋めながら開発していて､行き当たりばったりで書いていくので必ずどこかが壊れていたり､エラーが出るたびにフレームワーク名+警告文で一つずつGoogle検索していくことも少なくありませんでした｡
APIの実装例を調べて､コードを書いて､画面の表示確認して､コードを修正するという試行錯誤を繰り返すというフロントエンド開発な地道な面を体感しました｡
vte.cxは簡単に慣れて､扱いやすかったです｡学ぶべき強力な機能もたくさんあります｡
以上で学んだ経験と知識を業務に活かすとともに､CSSを仲間にすること､Material UIのカスタマイズ､テストの見識を深めることを個人的な課題として取り組んでまいります｡
